import itertools as itr
import time as time

def singletonSubCovers(causes, M, w, verbose=False, timeout=300):
    """
    Finds all singleton covers for each sub-sequence of an observed sequence.
    Inputs:
        causes: The handle to the causes function that defines the causal relation.
        M: The upper bound on the length of any effect sequence in the causal relation.
        w: The observed sequence to be explained.
        verbose: Boolean flag for whether to print out status updates.
        timeout: The maximum number of seconds to allow singletonSubCovers to run.
    Outputs:
        status: True if the run finished, False if it timed out.
        g: The table of singleton sub-covers.
           g[j,k] is a set of tuples of the form (u, v, d_min, d_max, ts), where
                u is a singleton cover of w[j:k],
                v is u's immediate child sequence in the covering tree,
                d_min is the shortest causal chain length in the covering tree,
                d_max is the longest causal chain length in the covering tree,
                ts is the total number of nodes in the covering tree.
    """
    start = time.clock()
    # Initialize g
    N = len(w)
    g = [{(j,k): set() for (j,k) in itr.combinations(range(N+1),2)}]
    for j in range(N):
        g[0][j,j+1] =  set([(w[j], (), 0, 0, 1)]) # 0-based indexing into w
    for ell in itr.count(1):
        g.append({(j,k): set(g[ell-1][j,k]) for (j,k) in g[ell-1]}) # copy (ell-1) covers
        for m in range(1,M+1):
            for k in itr.combinations(range(N+1),m+1):
                for uvdt in itr.product(*[g[ell-1][k[i-1],k[i]] for i in range(1,m+1)]):
                    if time.clock()-start > timeout:
                        return False, g[ell]
                    u = tuple(u for (u,_,_,_,_) in uvdt)
                    d_min = min(d for (_,_,d,_,_) in uvdt) + 1
                    d_max = max(d for (_,_,_,d,_) in uvdt) + 1
                    ts = sum(s for (_,_,_,_,s) in uvdt) + 1
                    g[ell][k[0],k[m]] |= set((cu, u, d_min, d_max, ts) for cu in causes(u))
        if verbose:
            print("ell=%d, max |g| = %d"%(ell, max([len(g[ell][jk]) for jk in g[ell]])))
        if g[ell]==g[ell-1]:
            return True, g[ell]

def topLevelCovers(g, N, M, u=(), k=(0,), d_min=(), d_max=(), ts=()):
    """
    A python generator that yields all top-level covers for an observed sequence.
    Inputs:
        g: the table of singleton sub-covers as returned by singletonSubCovers.
        N: the length of the observed sequence.
        M: The upper bound on the length of any effect sequence in the causal relation.
        u, k, d_min, d_max, ts: internal accumulators (not user-level inputs)
    Outputs:
        t: a top-level cover of the form (u, k, d_min, d_max, ts), where 
            u[i] is the i^{th} root in the covering forest,
            k[i] is the index of the first observation covered by u[i],
            d_min[i] is the shortest causal chain length in u[i]'s covering tree,
            d_max[i] is the longest causal chain length in u[i]'s covering tree,
            ts[i] is the total number of nodes in u[i]'s covering tree.
    """
    if k[-1]==N:
        yield (u, k, d_min, d_max, ts)
    else:
        for k1 in range(k[-1]+1,N+1):
            for (u1,_,d1_min, d1_max, ts1) in g[k[-1],k1]:
                if any([(u+(u1,))[-m:] == v for m in range(1,min(len(k),M)+1) for (_,v,_,_,_) in g[k[-m],k1]]):
                    continue
                for t in topLevelCovers(g, N, M, u+(u1,), k+(k1,), d_min+(d1_min,), d_max+(d1_max,), ts+(ts1,)):
                    yield t

def explain(causes, w, M=None, verbose=False, timeout=600, max_tlcovs=13000000):
    """
    Computes all explanations (top-level covers) for an observed sequence.
    Inputs:
        causes: A handle to the causes function.
        w: The observed sequence to be explained.
        M: The upper bound on the length of any effect sequence in the causal relation.
        verbose: Boolean flag for whether to print out status updates.
        timeout: The maximum number of seconds to allow explain to run.
        max_tlcovs: The maximum number of top-level covers to enumerate.
    Outputs:
        status: String indicating exit status: "Success", "SS covers timed out", "TL covers timed out", or "TL covers maxed out".
        tlcovs: A list of top-level covers as generated by topLevelCovers.
        g: The table of singleton sub-covers
    """
    if M is None: M = len(w)
    if verbose: print("Constructing explanations...")
    tlcovs = []
    start = time.clock()
    status, g = singletonSubCovers(causes, M, w, verbose=verbose, timeout=timeout)
    if status == False:
        if verbose: print("singletonSubCovers timed out :(")
        return "SS covers timed out", tlcovs, g
    for t in topLevelCovers(g, len(w), M):
        tlcovs.append(t)
        if time.clock()-start > timeout:
            if verbose: print("topLevelCovers timed out :(")
            return "TL covers timed out", tlcovs, g
        if len(tlcovs) > max_tlcovs:
            if verbose: print("topLevelCovers maxed out :(")
            return "TL covers maxed out", tlcovs, g
    if verbose: print("Success!")
    return "Success", tlcovs, g

def minCardinalityTLCovers(tlcovs):
    """
    Prune top-level covers for minimum cardinality
    Inputs:
        tlcovs: A list of top-level covers as returned by explain.
    Outputs:
        tlcovs_mc: The pruned top level covers.
        mc: The minimum cardinality found.
    """
    mc = min(len(u) for (u,_,_,_,_) in tlcovs)
    tlcovs_mc = [(u,k,d_min,d_max,ts) for (u,k,d_min,d_max,ts) in tlcovs if len(u) == mc]
    return tlcovs_mc, mc

def maxDepthTLCovers(tlcovs):
    """
    Prune top-level covers for maximum depth
    Inputs:
        tlcovs: A list of top-level covers as returned by explain.
    Outputs:
        tlcovs_md: The pruned top level covers.
        md: The maximum depth found.
    """
    md = max(max(d_max) for (_,_,_,d_max,_) in tlcovs)
    tlcovs_md = [(u,k,d_min,d_max,ts) for (u,k,d_min,d_max,ts) in tlcovs if max(d_max) == md]
    return tlcovs_md, md

def minimaxDepthTLCovers(tlcovs):
    """
    Prune top-level covers for minimax depth
    Inputs:
        tlcovs: A list of top-level covers as returned by explain.
    Outputs:
        tlcovs_xd: The pruned top level covers.
        xd: The minimax depth found.
    """
    xd = max(min(d_min) for (_,_,d_min,_,_) in tlcovs)
    tlcovs_xd = [(u,k,d_min,d_max,ts) for (u,k,d_min,d_max,ts) in tlcovs if min(d_min) == xd]
    return tlcovs_xd, xd

def minForestSizeTLCovers(tlcovs):
    """
    Prune top-level covers for minimum forest size
    Inputs:
        tlcovs: A list of top-level covers as returned by explain.
    Outputs:
        tlcovs_fs_min: The pruned top level covers.
        fs_min: The minimum forest size found.
    """
    fs_min = min(sum(ts) for (_,_,_,_,ts) in tlcovs)
    tlcovs_fs_min = [(u,k,d_min,d_max,ts) for (u,k,d_min,d_max,ts) in tlcovs if sum(ts) == fs_min]
    return tlcovs_fs_min, fs_min

def maxForestSizeTLCovers(tlcovs):
    """
    Prune top-level covers for maximum forest size
    Inputs:
        tlcovs: A list of top-level covers as returned by explain.
    Outputs:
        tlcovs_fs_max: The pruned top level covers.
        fs_max: The maximum forest size found.
    """
    fs_max = max(sum(ts) for (_,_,_,_,ts) in tlcovs)
    tlcovs_fs_max = [(u,k,d_min,d_max,ts) for (u,k,d_min,d_max,ts) in tlcovs if sum(ts) == fs_max]
    return tlcovs_fs_max, fs_max

def irredundantTLCovers(tlcovs, timeout=300):
    """
    Prune top-level covers for irredundancy
    Inputs:
        tlcovs: A list of top-level covers as returned by explain.
        timeout: The maximum number of seconds to allow irredundantTLCovers to run.
    Outputs:
        status: True if the run finished, False if it timed out.
        tlcovs_irr: The pruned top level covers.
    """
    tlcovs_irr = []
    start = time.clock()
    for (u,k,d_min,d_max,ts) in tlcovs:
        u_is_irr = True # until proven otherwise
        for (other_u,_,_,_,_) in tlcovs:
            if time.clock()-start > timeout:
                return False, tlcovs_irr
            # skip u1
            if u==other_u: continue
            # check if other_u is a sub-sequence of u
            if len(other_u) > len(u):
                is_sub_seq = False
            else:
                is_sub_seq = True # until proven otherwise
                u_tail = u
                for other_u_i in other_u:
                    if other_u_i in u_tail:
                        u_tail = u_tail[u_tail.index(other_u_i)+1:]
                    else:
                        is_sub_seq = False
                        break
            # other_u is a sub-sequence of u, u is redundant
            if is_sub_seq:
                u_is_irr = False
                break
        if u_is_irr:
            tlcovs_irr.append((u,k,d_min,d_max,ts))
    return True, tlcovs_irr

def minParametersTLCovers(tlcovs):
    # def count_params(u):
    #     return len(set([param for u_ in u for param in u_[2]]))
    count_params = lambda u: len(set([param for u_ in u for param in u_[2]]))
    mp = min([count_params(u) for (u,_,_,_,_) in tlcovs])
    tlcovs_mp = [(u,k,d_min,d_max,ts) for (u,k,d_min,d_max,ts) in tlcovs if count_params(u)==mp]
    return tlcovs_mp, mp
